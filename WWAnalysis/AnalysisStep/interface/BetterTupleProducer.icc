#include "WWAnalysis/AnalysisStep/interface/BetterTupleProducer.h"


template <class T> BetterTupleProducer<T>::BetterTupleProducer(const edm::ParameterSet& cfg) : 
        skimTag_(cfg.getUntrackedParameter<edm::InputTag>("src")), 
        plotsInfo_(cfg.getUntrackedParameter<std::vector<edm::ParameterSet> >("variables")),
        weight_(cfg.getUntrackedParameter<double>("weight")) {

    fs_ = edm::Service<TFileService>().operator->();
    tree_ = fs_->make<TTree>(cfg.getParameter<std::string>("@module_label").c_str(),cfg.getParameter<std::string>("@module_label").c_str());
    tree_->Branch("weight",&weight_,"weight/F");

}

template <class T> void BetterTupleProducer<T>::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup) {

    edm::Handle<std::vector< T > > skimH;
    iEvent.getByLabel(skimTag_,skimH);
    

    //Loop Over Each Plot Type
    for(size_t i=0;i<skimH->size();++i) {
        for(size_t j=0;j<plotsInfo_.size();++j) {
            placeHolder_[j] = objFuncs_[j](skimH->at(i));
        }            
        tree_->Fill();
    }

}

template <class T> void BetterTupleProducer<T>::beginJob() { 

    placeHolder_.clear();
    objFuncs_.clear();

    placeHolder_.resize(plotsInfo_.size());

    for(size_t j=0;j<plotsInfo_.size();++j) {
        objFuncs_.push_back( StringObjectFunction< T >(
                             plotsInfo_[j].getUntrackedParameter<std::string>("quantity")));
        tree_->Branch( plotsInfo_[j].getUntrackedParameter<std::string>("tag").c_str() , 
                       &placeHolder_[j], 
                       (plotsInfo_[j].getUntrackedParameter<std::string>("tag")+"/F").c_str() );
    }

}

template <class T> BetterTupleProducer<T>::~BetterTupleProducer() { } 
template <class T> void BetterTupleProducer<T>::endJob() { }

